---
layout: post
title:  "Jest 筆記"
date:   2022-10-27 11:17:00 +0800
categories: notes
author: "愛喝茶的熊"
tags: unit-test jest
---
# 外部Library的mock方法
```js
import { function1, function2 } from 'library';

jest.mock('library', () => {
  return {
    function1: jest.fn(),
    function2: jest.fn(),
  };
});
```

[官網](https://jestjs.io/docs/bypassing-module-mocks)有列出下列方法:
(關於mock會提升到最前面官網的解釋在[這裡](https://jestjs.io/docs/es6-class-mocks#calling-jestmock-with-the-module-factory-parameter))
```js
jest.mock('node-fetch'); // 這裡是因為jest會把mock提升到最前面執行

import fetch, {Response} from 'node-fetch';
import {createUser} from './createUser';

// jest.mock('node-fetch'); <-原本應該是在這邊

test('createUser calls fetch with the right args and returns the user id', async () => {
  fetch.mockReturnValue(Promise.resolve(new Response('4'))); // fetch是class

  const userId = await createUser();

  expect(fetch).toHaveBeenCalledTimes(1);
  expect(fetch).toHaveBeenCalledWith('https://website.com/users', {
    method: 'POST',
  });
  expect(userId).toBe('4');
});
```
但我實測必須是**class**才能直接mock後執行.mockReturnValue()或.mockImplementation()，不然會出現`library._default.mockImplementation is not a function`error。所以推測fetch應該是以class export出來的class。